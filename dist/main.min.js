"use strict";
var HomeWork = /** @class */ (function () {
    function HomeWork(name) {
        this.width = 300;
        this.height = 300;
        this.name = name;
        this.work = work;
        WorkManager.getInstance().addWork(name, this);
    }
    HomeWork.prototype.init = function () { };
    HomeWork.prototype.update = function () { };
    HomeWork.prototype.destroy = function () { };
    return HomeWork;
}());
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var ImageUtils = /** @class */ (function () {
    function ImageUtils() {
    }
    ImageUtils.load = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (res, rej) {
                        var i = new Image();
                        i.src = url;
                        i.onload = function () {
                            res(i);
                        };
                        i.onerror = function () {
                            rej(i);
                        };
                    })];
            });
        });
    };
    return ImageUtils;
}());
var WorkManager = /** @class */ (function () {
    function WorkManager() {
        var _this = this;
        this.timerFunction = null;
        this.KeyDownFn = {};
        this.KeyUpFn = {};
        this.WorkObjectPool = {};
        var self = this;
        this.list = document.querySelector("#list");
        this.btn = document.querySelector("#runit");
        this.btn.onclick = function () {
            var value = self.list.selectedOptions[0].value;
            if (!value)
                alert("\u4E0D\u5B58\u5728" + value + "\u7EC4\u4EF6");
            self.init(value);
        };
        this.render();
        document.body.addEventListener('keydown', function (e) {
            if (_this.KeyDownFn[e.key])
                _this.KeyDownFn[e.key]();
        });
        document.body.addEventListener('keyup', function (e) {
            if (_this.KeyUpFn[e.key])
                _this.KeyUpFn[e.key]();
        });
    }
    WorkManager.getInstance = function () {
        if (!this.instance)
            this.instance = new WorkManager();
        return this.instance;
    };
    WorkManager.prototype.keydown = function (key, fn) {
        this.KeyDownFn[key] = fn;
    };
    WorkManager.prototype.keyup = function (key, fn) {
        this.KeyUpFn[key] = fn;
    };
    WorkManager.prototype.render = function () {
        if (this.timerFunction)
            this.timerFunction();
        requestAnimationFrame(this.render.bind(this));
    };
    WorkManager.prototype.addWork = function (name, WO) {
        this.WorkObjectPool[name] = WO;
        this.updateList();
    };
    WorkManager.prototype.init = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.restore(this.WorkObjectPool[name].width, this.WorkObjectPool[name].height);
                        return [4 /*yield*/, this.WorkObjectPool[name].init()];
                    case 1:
                        _a.sent();
                        this.timerFunction = function () {
                            _this.WorkObjectPool[name].update();
                        };
                        return [2 /*return*/];
                }
            });
        });
    };
    WorkManager.prototype.start = function (index) {
        this.init(Object.keys(this.WorkObjectPool)[index]);
    };
    WorkManager.prototype.updateList = function () {
        var cnt = '';
        for (var i in this.WorkObjectPool) {
            cnt += "<option value=\"" + i + "\">" + i + "</option>";
        }
        this.list.innerHTML = cnt;
    };
    WorkManager.prototype.restore = function (w, h) {
        w = w || 300;
        h = h || 300;
        this.KeyDownFn = {};
        this.KeyUpFn = {};
        var context = document.querySelector("#context");
        var id = "view-" + Math.random().toString().replace('.', "");
        context.innerHTML = "<canvas id=\"" + id + "\" class=\"view\" width=\"" + w + "\" height=\"" + h + "\"></canvas>";
        console.log(id);
        work.view = document.querySelector("#" + id);
        if (!work.view) {
            alert('不存在视图');
            return;
        }
        work.gl = work.view.getContext("webgl");
    };
    return WorkManager;
}());
var MyWork = /** @class */ (function () {
    function MyWork() {
        this.view = document.querySelector("#view");
        if (!this.view) {
            alert('不存在视图');
            return;
        }
        this.gl = this.view.getContext("webgl");
    }
    MyWork.prototype.init = function () {
        new WrokWithTriangle("Triangle");
        new WorkWithTextures("Textures");
        new WorkWithTextures2("Textures2");
        new WorkWithTransformations("Transformations");
        new WorkWithTransformations2("Transformations2");
        new WorkWithTransformations3("Transformations3");
        "";
        new WorkWithCamera('Camera');
        new Work.intro.Camera2('Camera2');
        new Work.Lighting.Colors('Colors');
        new Work.Lighting.Lighting('Lighting');
    };
    MyWork.prototype.clear = function (indata) {
        var color = indata || [0.0, 0.5, 0.0, 1.0];
        var gl = this.gl;
        gl.clearColor(color[0], color[1], color[2], color[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
    };
    return MyWork;
}());
var Shader = /** @class */ (function () {
    function Shader() {
        this.gl = null;
        this.ID = null;
    }
    Shader.create = function (vertsrc, fragsrc, gl) {
        return __awaiter(this, void 0, void 0, function () {
            var shader, ID, vert, frag, vertexShader, fragmentShader, info, info, info;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        shader = new Shader();
                        shader.gl = gl;
                        ID = gl.createProgram();
                        shader.ID = ID;
                        return [4 /*yield*/, $.get(vertsrc)];
                    case 1:
                        vert = _a.sent();
                        return [4 /*yield*/, $.get(fragsrc)];
                    case 2:
                        frag = _a.sent();
                        vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(vertexShader, vert);
                        gl.shaderSource(fragmentShader, frag);
                        gl.compileShader(vertexShader);
                        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(vertexShader);
                            throw info;
                        }
                        gl.compileShader(fragmentShader);
                        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(fragmentShader);
                            throw info;
                        }
                        gl.attachShader(ID, vertexShader);
                        gl.attachShader(ID, fragmentShader);
                        gl.linkProgram(ID);
                        if (!gl.getProgramParameter(ID, gl.LINK_STATUS)) {
                            info = gl.getProgramInfoLog(ID);
                            throw 'Could not compile WebGL program. \n\n' + info;
                        }
                        gl.deleteShader(vertexShader);
                        gl.deleteShader(fragmentShader);
                        return [2 /*return*/, shader];
                }
            });
        });
    };
    Shader.prototype.use = function () {
        this.gl.useProgram(this.ID);
    };
    Shader.prototype.setBool = function (name, value) {
        var local = this.gl.getUniformLocation(this.ID, name);
        this.gl.uniform1i(local, ~~value);
    };
    Shader.prototype.setInt = function (name, value) {
        var local = this.gl.getUniformLocation(this.ID, name);
        this.gl.uniform1i(local, value);
    };
    Shader.prototype.setFloat = function (name, value) {
        var local = this.gl.getUniformLocation(this.ID, name);
        this.gl.uniform1f(local, value);
    };
    Shader.prototype.setVec3 = function (name, value) {
        var local = this.gl.getUniformLocation(this.ID, name);
        this.gl.uniform3fv(local, value);
    };
    Shader.prototype.setMat4 = function (name, value) {
        var local = this.gl.getUniformLocation(this.ID, name);
        this.gl.uniformMatrix4fv(local, false, value);
    };
    return Shader;
}());
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Work;
(function (Work) {
    var Lighting;
    (function (Lighting) {
        var Colors = /** @class */ (function (_super) {
            __extends(Colors, _super);
            function Colors() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.vertices = [
                    -0.5, -0.5, -0.5, 0.0, 0.0,
                    0.5, -0.5, -0.5, 1.0, 0.0,
                    0.5, 0.5, -0.5, 1.0, 1.0,
                    0.5, 0.5, -0.5, 1.0, 1.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0,
                    -0.5, -0.5, -0.5, 0.0, 0.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0,
                    0.5, -0.5, 0.5, 1.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 1.0,
                    0.5, 0.5, 0.5, 1.0, 1.0,
                    -0.5, 0.5, 0.5, 0.0, 1.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0,
                    -0.5, 0.5, 0.5, 1.0, 0.0,
                    -0.5, 0.5, -0.5, 1.0, 1.0,
                    -0.5, -0.5, -0.5, 0.0, 1.0,
                    -0.5, -0.5, -0.5, 0.0, 1.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0,
                    -0.5, 0.5, 0.5, 1.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0,
                    0.5, 0.5, -0.5, 1.0, 1.0,
                    0.5, -0.5, -0.5, 0.0, 1.0,
                    0.5, -0.5, -0.5, 0.0, 1.0,
                    0.5, -0.5, 0.5, 0.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0,
                    -0.5, -0.5, -0.5, 0.0, 1.0,
                    0.5, -0.5, -0.5, 1.0, 1.0,
                    0.5, -0.5, 0.5, 1.0, 0.0,
                    0.5, -0.5, 0.5, 1.0, 0.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0,
                    -0.5, -0.5, -0.5, 0.0, 1.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0,
                    0.5, 0.5, -0.5, 1.0, 1.0,
                    0.5, 0.5, 0.5, 1.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0,
                    -0.5, 0.5, 0.5, 0.0, 0.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0
                ];
                _this.width = 960;
                _this.height = 540;
                _this.key_status = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                _this.started = false;
                _this.angle = 0;
                _this.cameraPos = vec3.fromValues(0, 0, 3);
                _this.cameraFront = vec3.fromValues(0.0, 0.0, -1.0);
                _this.cameraUp = vec3.fromValues(0.0, 1.0, 0.0);
                _this.cameraSpeed = 0.2;
                _this.lightPos = vec3.fromValues(1.0, 1.2, -2.0);
                return _this;
            }
            Colors.prototype.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, _a, shader, _b, program, VBO, v, aPos, aTexCoord;
                    var _this = this;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                gl = this.work.gl;
                                _a = this;
                                return [4 /*yield*/, Shader.create('./glsl/transfromations2.vert', './glsl/colors.lamp.frag', gl)];
                            case 1:
                                _a.lampshader = _c.sent();
                                _b = this;
                                return [4 /*yield*/, Shader.create('./glsl/transfromations2.vert', './glsl/colors.frag', gl)];
                            case 2:
                                shader = _b.shader = _c.sent();
                                program = this.program = shader.ID;
                                VBO = this.VBO = gl.createBuffer();
                                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                                v = new Float32Array(this.vertices);
                                gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                                aPos = gl.getAttribLocation(program, 'aPos');
                                gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 0);
                                gl.enableVertexAttribArray(aPos);
                                aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
                                gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                                gl.enableVertexAttribArray(aTexCoord);
                                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                                WorkManager.getInstance().keydown("w", function () {
                                    _this.key_status.w = true;
                                });
                                WorkManager.getInstance().keydown("a", function () {
                                    _this.key_status.a = true;
                                });
                                WorkManager.getInstance().keydown("s", function () {
                                    _this.key_status.s = true;
                                });
                                WorkManager.getInstance().keydown("d", function () {
                                    _this.key_status.d = true;
                                });
                                WorkManager.getInstance().keyup("w", function () {
                                    _this.key_status.w = false;
                                });
                                WorkManager.getInstance().keyup("a", function () {
                                    _this.key_status.a = false;
                                });
                                WorkManager.getInstance().keyup("s", function () {
                                    _this.key_status.s = false;
                                });
                                WorkManager.getInstance().keyup("d", function () {
                                    _this.key_status.d = false;
                                });
                                return [2 /*return*/];
                        }
                    });
                });
            };
            Colors.prototype.update = function () {
                var gl = this.work.gl;
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0.2, 0.3, 0.3, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.tex);
                this.angle++;
                // let transform = gl.getUniformLocation(this.program, 'transform');
                // let model = gl.getUniformLocation(this.program, 'model');
                // let view = gl.getUniformLocation(this.program, 'view');
                // let projection = gl.getUniformLocation(this.program, 'projection');
                gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
                // let radius = 10.0;
                // let camX = Math.sin(this.angle / 100) * radius;
                // let camZ = Math.cos(this.angle / 100) * radius;
                if (this.key_status.w) {
                    this.cameraPos[2] += this.cameraFront[2] * this.cameraSpeed;
                }
                if (this.key_status.s) {
                    this.cameraPos[2] -= this.cameraFront[2] * this.cameraSpeed;
                }
                if (this.key_status.a) {
                    var v = vec3.create();
                    vec3.cross(v, this.cameraFront, this.cameraUp);
                    this.cameraPos[0] -= v[0] * this.cameraSpeed;
                    this.cameraPos[1] -= v[1] * this.cameraSpeed;
                    this.cameraPos[2] -= v[2] * this.cameraSpeed;
                }
                if (this.key_status.d) {
                    var v = vec3.create();
                    vec3.cross(v, this.cameraFront, this.cameraUp);
                    this.cameraPos[0] += v[0] * this.cameraSpeed;
                    this.cameraPos[1] += v[1] * this.cameraSpeed;
                    this.cameraPos[2] += v[2] * this.cameraSpeed;
                }
                //projection
                var promat = mat4.create();
                mat4.perspective(promat, 3.14 / 4, this.width / this.height, 0.1, 100.0);
                //view
                var viewmat = mat4.create();
                mat4.lookAt(viewmat, this.cameraPos, vec3.add(vec3.create(), this.cameraPos, this.cameraFront), this.cameraUp);
                //model
                var modelvec3 = vec3.fromValues(0, 0, 0);
                var modelmat = mat4.create();
                mat4.translate(modelmat, modelmat, modelvec3);
                this.shader.use();
                this.shader.setMat4('projection', promat);
                this.shader.setMat4('view', viewmat);
                this.shader.setMat4('model', modelmat);
                this.shader.setVec3('lightColor', vec3.fromValues(1, 1, 1));
                this.shader.setVec3('objectColor', vec3.fromValues(1, 0.5, 0.31));
                gl.drawArrays(gl.TRIANGLES, 0, 36);
                modelmat = mat4.create();
                mat4.translate(modelmat, modelmat, this.lightPos);
                mat4.scale(modelmat, modelmat, vec3.fromValues(0.3, 0.3, 0.3));
                this.lampshader.use();
                this.lampshader.setMat4('projection', promat);
                this.lampshader.setMat4('view', viewmat);
                this.lampshader.setMat4('model', modelmat);
                gl.drawArrays(gl.TRIANGLES, 0, 36);
            };
            return Colors;
        }(HomeWork));
        Lighting.Colors = Colors;
    })(Lighting = Work.Lighting || (Work.Lighting = {}));
})(Work || (Work = {}));
var Work;
(function (Work) {
    var Lighting;
    (function (Lighting_1) {
        var Lighting = /** @class */ (function (_super) {
            __extends(Lighting, _super);
            function Lighting() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.vertices = [
                    -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,
                    0.5, -0.5, -0.5, 0.0, 0.0, -1.0,
                    0.5, 0.5, -0.5, 0.0, 0.0, -1.0,
                    0.5, 0.5, -0.5, 0.0, 0.0, -1.0,
                    -0.5, 0.5, -0.5, 0.0, 0.0, -1.0,
                    -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,
                    0.5, -0.5, 0.5, 0.0, 0.0, 1.0,
                    0.5, 0.5, 0.5, 0.0, 0.0, 1.0,
                    0.5, 0.5, 0.5, 0.0, 0.0, 1.0,
                    -0.5, 0.5, 0.5, 0.0, 0.0, 1.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,
                    -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,
                    -0.5, 0.5, -0.5, -1.0, 0.0, 0.0,
                    -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,
                    -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,
                    -0.5, -0.5, 0.5, -1.0, 0.0, 0.0,
                    -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0, 0.0,
                    0.5, 0.5, -0.5, 1.0, 0.0, 0.0,
                    0.5, -0.5, -0.5, 1.0, 0.0, 0.0,
                    0.5, -0.5, -0.5, 1.0, 0.0, 0.0,
                    0.5, -0.5, 0.5, 1.0, 0.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0, 0.0,
                    -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,
                    0.5, -0.5, -0.5, 0.0, -1.0, 0.0,
                    0.5, -0.5, 0.5, 0.0, -1.0, 0.0,
                    0.5, -0.5, 0.5, 0.0, -1.0, 0.0,
                    -0.5, -0.5, 0.5, 0.0, -1.0, 0.0,
                    -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0, 0.0,
                    0.5, 0.5, -0.5, 0.0, 1.0, 0.0,
                    0.5, 0.5, 0.5, 0.0, 1.0, 0.0,
                    0.5, 0.5, 0.5, 0.0, 1.0, 0.0,
                    -0.5, 0.5, 0.5, 0.0, 1.0, 0.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0, 0.0
                ];
                _this.width = 960;
                _this.height = 540;
                _this.key_status = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                _this.started = false;
                _this.angle = 0;
                _this.cameraPos = vec3.fromValues(0, 0, 3);
                _this.cameraFront = vec3.fromValues(0.0, 0.0, -1.0);
                _this.cameraUp = vec3.fromValues(0.0, 1.0, 0.0);
                _this.cameraSpeed = 0.2;
                _this.lightPos = vec3.fromValues(1.0, 1.2, -2.0);
                return _this;
            }
            Lighting.prototype.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, _a, shader, _b, program, VBO, v, aPos, aTexCoord;
                    var _this = this;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                gl = this.work.gl;
                                _a = this;
                                return [4 /*yield*/, Shader.create('./glsl/transfromations2.vert', './glsl/colors.lamp.frag', gl)];
                            case 1:
                                _a.lampshader = _c.sent();
                                _b = this;
                                return [4 /*yield*/, Shader.create('./glsl/lighting/lighting.normal.vert', './glsl/lighting/lighting.ambient.frag', gl)];
                            case 2:
                                shader = _b.shader = _c.sent();
                                program = this.program = shader.ID;
                                VBO = this.VBO = gl.createBuffer();
                                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                                v = new Float32Array(this.vertices);
                                gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                                aPos = gl.getAttribLocation(program, 'aPos');
                                gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 6 * v.BYTES_PER_ELEMENT, 0);
                                gl.enableVertexAttribArray(aPos);
                                aTexCoord = gl.getAttribLocation(program, 'aNormal');
                                gl.vertexAttribPointer(aTexCoord, 3, gl.FLOAT, false, 6 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                                gl.enableVertexAttribArray(aTexCoord);
                                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                                WorkManager.getInstance().keydown("w", function () {
                                    _this.key_status.w = true;
                                });
                                WorkManager.getInstance().keydown("a", function () {
                                    _this.key_status.a = true;
                                });
                                WorkManager.getInstance().keydown("s", function () {
                                    _this.key_status.s = true;
                                });
                                WorkManager.getInstance().keydown("d", function () {
                                    _this.key_status.d = true;
                                });
                                WorkManager.getInstance().keyup("w", function () {
                                    _this.key_status.w = false;
                                });
                                WorkManager.getInstance().keyup("a", function () {
                                    _this.key_status.a = false;
                                });
                                WorkManager.getInstance().keyup("s", function () {
                                    _this.key_status.s = false;
                                });
                                WorkManager.getInstance().keyup("d", function () {
                                    _this.key_status.d = false;
                                });
                                return [2 /*return*/];
                        }
                    });
                });
            };
            Lighting.prototype.update = function () {
                var gl = this.work.gl;
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0, 0, 0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.tex);
                this.angle++;
                // let transform = gl.getUniformLocation(this.program, 'transform');
                // let model = gl.getUniformLocation(this.program, 'model');
                // let view = gl.getUniformLocation(this.program, 'view');
                // let projection = gl.getUniformLocation(this.program, 'projection');
                gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
                // let radius = 10.0;
                // let camX = Math.sin(this.angle / 100) * radius;
                // let camZ = Math.cos(this.angle / 100) * radius;
                if (this.key_status.w) {
                    this.cameraPos[2] += this.cameraFront[2] * this.cameraSpeed;
                }
                if (this.key_status.s) {
                    this.cameraPos[2] -= this.cameraFront[2] * this.cameraSpeed;
                }
                if (this.key_status.a) {
                    var v = vec3.create();
                    vec3.cross(v, this.cameraFront, this.cameraUp);
                    this.cameraPos[0] -= v[0] * this.cameraSpeed;
                    this.cameraPos[1] -= v[1] * this.cameraSpeed;
                    this.cameraPos[2] -= v[2] * this.cameraSpeed;
                }
                if (this.key_status.d) {
                    var v = vec3.create();
                    vec3.cross(v, this.cameraFront, this.cameraUp);
                    this.cameraPos[0] += v[0] * this.cameraSpeed;
                    this.cameraPos[1] += v[1] * this.cameraSpeed;
                    this.cameraPos[2] += v[2] * this.cameraSpeed;
                }
                //projection
                var promat = mat4.create();
                mat4.perspective(promat, 3.14 / 4, this.width / this.height, 0.1, 100.0);
                //view
                var viewmat = mat4.create();
                mat4.lookAt(viewmat, this.cameraPos, vec3.add(vec3.create(), this.cameraPos, this.cameraFront), this.cameraUp);
                //model
                var modelvec3 = vec3.fromValues(0, 0, 0);
                var modelmat = mat4.create();
                mat4.translate(modelmat, modelmat, modelvec3);
                this.shader.use();
                this.shader.setMat4('projection', promat);
                this.shader.setMat4('view', viewmat);
                this.shader.setMat4('model', modelmat);
                this.shader.setVec3('lightColor', vec3.fromValues(1, 1, 1));
                this.shader.setVec3('objectColor', vec3.fromValues(1, 0.5, 0.31));
                gl.drawArrays(gl.TRIANGLES, 0, 36);
                //lamp
                modelmat = mat4.create();
                mat4.translate(modelmat, modelmat, this.lightPos);
                mat4.scale(modelmat, modelmat, vec3.fromValues(0.3, 0.3, 0.3));
                this.lampshader.use();
                this.lampshader.setMat4('projection', promat);
                this.lampshader.setMat4('view', viewmat);
                this.lampshader.setMat4('model', modelmat);
                gl.drawArrays(gl.TRIANGLES, 0, 36);
            };
            return Lighting;
        }(HomeWork));
        Lighting_1.Lighting = Lighting;
    })(Lighting = Work.Lighting || (Work.Lighting = {}));
})(Work || (Work = {}));
var Work;
(function (Work) {
    var Lighting;
    (function (Lighting) {
        var LightingNormal = /** @class */ (function (_super) {
            __extends(LightingNormal, _super);
            function LightingNormal() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.vertices = [
                    -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,
                    0.5, -0.5, -0.5, 0.0, 0.0, -1.0,
                    0.5, 0.5, -0.5, 0.0, 0.0, -1.0,
                    0.5, 0.5, -0.5, 0.0, 0.0, -1.0,
                    -0.5, 0.5, -0.5, 0.0, 0.0, -1.0,
                    -0.5, -0.5, -0.5, 0.0, 0.0, -1.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,
                    0.5, -0.5, 0.5, 0.0, 0.0, 1.0,
                    0.5, 0.5, 0.5, 0.0, 0.0, 1.0,
                    0.5, 0.5, 0.5, 0.0, 0.0, 1.0,
                    -0.5, 0.5, 0.5, 0.0, 0.0, 1.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0, 1.0,
                    -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,
                    -0.5, 0.5, -0.5, -1.0, 0.0, 0.0,
                    -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,
                    -0.5, -0.5, -0.5, -1.0, 0.0, 0.0,
                    -0.5, -0.5, 0.5, -1.0, 0.0, 0.0,
                    -0.5, 0.5, 0.5, -1.0, 0.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0, 0.0,
                    0.5, 0.5, -0.5, 1.0, 0.0, 0.0,
                    0.5, -0.5, -0.5, 1.0, 0.0, 0.0,
                    0.5, -0.5, -0.5, 1.0, 0.0, 0.0,
                    0.5, -0.5, 0.5, 1.0, 0.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0, 0.0,
                    -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,
                    0.5, -0.5, -0.5, 0.0, -1.0, 0.0,
                    0.5, -0.5, 0.5, 0.0, -1.0, 0.0,
                    0.5, -0.5, 0.5, 0.0, -1.0, 0.0,
                    -0.5, -0.5, 0.5, 0.0, -1.0, 0.0,
                    -0.5, -0.5, -0.5, 0.0, -1.0, 0.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0, 0.0,
                    0.5, 0.5, -0.5, 0.0, 1.0, 0.0,
                    0.5, 0.5, 0.5, 0.0, 1.0, 0.0,
                    0.5, 0.5, 0.5, 0.0, 1.0, 0.0,
                    -0.5, 0.5, 0.5, 0.0, 1.0, 0.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0, 0.0
                ];
                _this.width = 960;
                _this.height = 540;
                _this.key_status = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                _this.started = false;
                _this.angle = 0;
                _this.cameraPos = vec3.fromValues(0, 0, 3);
                _this.cameraFront = vec3.fromValues(0.0, 0.0, -1.0);
                _this.cameraUp = vec3.fromValues(0.0, 1.0, 0.0);
                _this.cameraSpeed = 0.2;
                _this.lightPos = vec3.fromValues(1.0, 1.2, -2.0);
                return _this;
            }
            LightingNormal.prototype.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, _a, shader, _b, program, VBO, v, aPos, aTexCoord;
                    var _this = this;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                gl = this.work.gl;
                                _a = this;
                                return [4 /*yield*/, Shader.create('./glsl/transfromations2.vert', './glsl/colors.lamp.frag', gl)];
                            case 1:
                                _a.lampshader = _c.sent();
                                _b = this;
                                return [4 /*yield*/, Shader.create('./glsl/lighting/lighting.normal.vert', './glsl/lighting/lighting.normal.frag', gl)];
                            case 2:
                                shader = _b.shader = _c.sent();
                                program = this.program = shader.ID;
                                VBO = this.VBO = gl.createBuffer();
                                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                                v = new Float32Array(this.vertices);
                                gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                                aPos = gl.getAttribLocation(program, 'aPos');
                                gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 6 * v.BYTES_PER_ELEMENT, 0);
                                gl.enableVertexAttribArray(aPos);
                                aTexCoord = gl.getAttribLocation(program, 'aNormal');
                                gl.vertexAttribPointer(aTexCoord, 3, gl.FLOAT, false, 6 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                                gl.enableVertexAttribArray(aTexCoord);
                                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                                WorkManager.getInstance().keydown("w", function () {
                                    _this.key_status.w = true;
                                });
                                WorkManager.getInstance().keydown("a", function () {
                                    _this.key_status.a = true;
                                });
                                WorkManager.getInstance().keydown("s", function () {
                                    _this.key_status.s = true;
                                });
                                WorkManager.getInstance().keydown("d", function () {
                                    _this.key_status.d = true;
                                });
                                WorkManager.getInstance().keyup("w", function () {
                                    _this.key_status.w = false;
                                });
                                WorkManager.getInstance().keyup("a", function () {
                                    _this.key_status.a = false;
                                });
                                WorkManager.getInstance().keyup("s", function () {
                                    _this.key_status.s = false;
                                });
                                WorkManager.getInstance().keyup("d", function () {
                                    _this.key_status.d = false;
                                });
                                return [2 /*return*/];
                        }
                    });
                });
            };
            LightingNormal.prototype.update = function () {
                var gl = this.work.gl;
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0, 0, 0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.tex);
                this.angle++;
                // let transform = gl.getUniformLocation(this.program, 'transform');
                // let model = gl.getUniformLocation(this.program, 'model');
                // let view = gl.getUniformLocation(this.program, 'view');
                // let projection = gl.getUniformLocation(this.program, 'projection');
                gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
                // let radius = 10.0;
                // let camX = Math.sin(this.angle / 100) * radius;
                // let camZ = Math.cos(this.angle / 100) * radius;
                if (this.key_status.w) {
                    this.cameraPos[2] += this.cameraFront[2] * this.cameraSpeed;
                }
                if (this.key_status.s) {
                    this.cameraPos[2] -= this.cameraFront[2] * this.cameraSpeed;
                }
                if (this.key_status.a) {
                    var v = vec3.create();
                    vec3.cross(v, this.cameraFront, this.cameraUp);
                    this.cameraPos[0] -= v[0] * this.cameraSpeed;
                    this.cameraPos[1] -= v[1] * this.cameraSpeed;
                    this.cameraPos[2] -= v[2] * this.cameraSpeed;
                }
                if (this.key_status.d) {
                    var v = vec3.create();
                    vec3.cross(v, this.cameraFront, this.cameraUp);
                    this.cameraPos[0] += v[0] * this.cameraSpeed;
                    this.cameraPos[1] += v[1] * this.cameraSpeed;
                    this.cameraPos[2] += v[2] * this.cameraSpeed;
                }
                //projection
                var promat = mat4.create();
                mat4.perspective(promat, 3.14 / 4, this.width / this.height, 0.1, 100.0);
                //view
                var viewmat = mat4.create();
                mat4.lookAt(viewmat, this.cameraPos, vec3.add(vec3.create(), this.cameraPos, this.cameraFront), this.cameraUp);
                //model
                var modelvec3 = vec3.fromValues(0, 0, 0);
                var modelmat = mat4.create();
                mat4.translate(modelmat, modelmat, modelvec3);
                this.shader.use();
                this.shader.setMat4('projection', promat);
                this.shader.setMat4('view', viewmat);
                this.shader.setMat4('model', modelmat);
                this.shader.setVec3('lightColor', vec3.fromValues(1, 1, 1));
                this.shader.setVec3('objectColor', vec3.fromValues(1, 0.5, 0.31));
                gl.drawArrays(gl.TRIANGLES, 0, 36);
                //lamp
                modelmat = mat4.create();
                mat4.translate(modelmat, modelmat, this.lightPos);
                mat4.scale(modelmat, modelmat, vec3.fromValues(0.3, 0.3, 0.3));
                this.lampshader.use();
                this.lampshader.setMat4('projection', promat);
                this.lampshader.setMat4('view', viewmat);
                this.lampshader.setMat4('model', modelmat);
                gl.drawArrays(gl.TRIANGLES, 0, 36);
            };
            return LightingNormal;
        }(HomeWork));
        Lighting.LightingNormal = LightingNormal;
    })(Lighting = Work.Lighting || (Work.Lighting = {}));
})(Work || (Work = {}));
var WorkWithCamera = /** @class */ (function (_super) {
    __extends(WorkWithCamera, _super);
    function WorkWithCamera() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vertices = [
            -0.5, -0.5, -0.5, 0.0, 0.0,
            0.5, -0.5, -0.5, 1.0, 0.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            -0.5, 0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 0.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 1.0,
            0.5, 0.5, 0.5, 1.0, 1.0,
            -0.5, 0.5, 0.5, 0.0, 1.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, 0.5, -0.5, 1.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, 0.5, 0.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, -0.5, 1.0, 1.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, 0.5, -0.5, 0.0, 1.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, 0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, -0.5, 0.0, 1.0
        ];
        _this.cubePositions = [
            vec3.fromValues(0.0, 0.0, 0.0),
            vec3.fromValues(2.0, 5.0, -15.0),
            vec3.fromValues(-1.5, -2.2, -2.5),
            vec3.fromValues(-3.8, -2.0, -12.3),
            vec3.fromValues(2.4, -0.4, -3.5),
            vec3.fromValues(-1.7, 3.0, -7.5),
            vec3.fromValues(1.3, -2.0, -2.5),
            vec3.fromValues(1.5, 2.0, -2.5),
            vec3.fromValues(1.5, 0.2, -1.5),
            vec3.fromValues(-1.3, 1.0, -1.5)
        ];
        _this.width = 960;
        _this.height = 540;
        _this.started = false;
        _this.angle = 0;
        _this.cameraPos = vec3.fromValues(0, 0, 3);
        return _this;
    }
    WorkWithCamera.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gl, program, vert, frag, vertexShader, fragmentShader, info, info, info, VBO, v, aPos, aTexCoord, ourTexture, tex, img;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.work.gl;
                        program = this.program = gl.createProgram();
                        return [4 /*yield*/, $.get('./glsl/transfromations2.vert')];
                    case 1:
                        vert = _a.sent();
                        return [4 /*yield*/, $.get('./glsl/transfromations2.frag')];
                    case 2:
                        frag = _a.sent();
                        vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(vertexShader, vert);
                        gl.shaderSource(fragmentShader, frag);
                        // console.log(vertexShader,fragmentShader);
                        gl.compileShader(vertexShader);
                        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(vertexShader);
                            throw info;
                        }
                        gl.compileShader(fragmentShader);
                        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(fragmentShader);
                            throw info;
                        }
                        gl.attachShader(program, vertexShader);
                        gl.attachShader(program, fragmentShader);
                        gl.linkProgram(program);
                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                            info = gl.getProgramInfoLog(program);
                            throw 'Could not compile WebGL program. \n\n' + info;
                        }
                        VBO = this.VBO = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        v = new Float32Array(this.vertices);
                        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                        aPos = gl.getAttribLocation(program, 'aPos');
                        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 0);
                        gl.enableVertexAttribArray(aPos);
                        aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
                        gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aTexCoord);
                        ourTexture = gl.getUniformLocation(program, 'ourTexture');
                        tex = this.tex = gl.createTexture();
                        return [4 /*yield*/, ImageUtils.load("/assets/cg001.jpg")];
                    case 3:
                        img = _a.sent();
                        gl.useProgram(program);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        //一系列tex处理阐述
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        //texture bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering.
                        //因为材质图默认很多图片不是所谓的标准尺寸，2^n这种 需要拉伸
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
                        gl.uniform1i(ourTexture, 0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        return [2 /*return*/];
                }
            });
        });
    };
    WorkWithCamera.prototype.update = function () {
        var gl = this.work.gl;
        gl.useProgram(this.program);
        gl.enable(gl.DEPTH_TEST);
        // gl.enable(gl.CULL_FACE);
        gl.clearColor(0.2, 0.3, 0.3, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
        this.angle++;
        // let transform = gl.getUniformLocation(this.program, 'transform');
        var model = gl.getUniformLocation(this.program, 'model');
        var view = gl.getUniformLocation(this.program, 'view');
        var projection = gl.getUniformLocation(this.program, 'projection');
        // let m2 = mat4.create();
        // let mat = mat4.create();
        var promat = mat4.create();
        var viewmat = mat4.create();
        // let v1 = vec3.fromValues(0.5, 1.0, 1.0)
        // mat4.rotate(m2, mat, this.angle * Math.PI / 180, v1);
        // mat4.translate(m2,mat4.create(), vec3.fromValues(0, 0, ));
        // mat4.lookAt(viewmat, [4, 4, 8], [0, 0, 0], [0, 1, 0]);
        mat4.perspective(promat, 3.14 / 4, this.width / this.height, 0.1, 100.0);
        // mat4.translate(viewmat, mat4.create(), vec3.fromValues(0, 0, -3.0))
        // gl.enable(gl.DEPTH_TEST);
        // gl.uniformMatrix4fv(transform, false, m2);
        gl.uniformMatrix4fv(projection, false, promat);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
        // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.EBO);
        // gl.drawElements(gl.TRIANGLE_STRIP, 6, gl.UNSIGNED_BYTE, 0);
        var radius = 10.0;
        var camX = Math.sin(this.angle / 100) * radius;
        var camZ = Math.cos(this.angle / 100) * radius;
        mat4.lookAt(viewmat, [camX, 0.0, camZ], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]);
        gl.uniformMatrix4fv(view, false, viewmat);
        for (var i in this.cubePositions) {
            var modelvec3 = this.cubePositions[i];
            var modelmat = mat4.create();
            mat4.translate(modelmat, modelmat, modelvec3);
            mat4.rotate(modelmat, modelmat, this.angle * (~~i + 2) / 10 * Math.PI / 180, vec3.fromValues(0.05, 0.0, 0.05));
            gl.uniformMatrix4fv(model, false, modelmat);
            gl.drawArrays(gl.TRIANGLES, 0, 36);
        }
    };
    return WorkWithCamera;
}(HomeWork));
var Work;
(function (Work) {
    var intro;
    (function (intro) {
        var Camera2 = /** @class */ (function (_super) {
            __extends(Camera2, _super);
            function Camera2() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.vertices = [
                    -0.5, -0.5, -0.5, 0.0, 0.0,
                    0.5, -0.5, -0.5, 1.0, 0.0,
                    0.5, 0.5, -0.5, 1.0, 1.0,
                    0.5, 0.5, -0.5, 1.0, 1.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0,
                    -0.5, -0.5, -0.5, 0.0, 0.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0,
                    0.5, -0.5, 0.5, 1.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 1.0,
                    0.5, 0.5, 0.5, 1.0, 1.0,
                    -0.5, 0.5, 0.5, 0.0, 1.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0,
                    -0.5, 0.5, 0.5, 1.0, 0.0,
                    -0.5, 0.5, -0.5, 1.0, 1.0,
                    -0.5, -0.5, -0.5, 0.0, 1.0,
                    -0.5, -0.5, -0.5, 0.0, 1.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0,
                    -0.5, 0.5, 0.5, 1.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0,
                    0.5, 0.5, -0.5, 1.0, 1.0,
                    0.5, -0.5, -0.5, 0.0, 1.0,
                    0.5, -0.5, -0.5, 0.0, 1.0,
                    0.5, -0.5, 0.5, 0.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0,
                    -0.5, -0.5, -0.5, 0.0, 1.0,
                    0.5, -0.5, -0.5, 1.0, 1.0,
                    0.5, -0.5, 0.5, 1.0, 0.0,
                    0.5, -0.5, 0.5, 1.0, 0.0,
                    -0.5, -0.5, 0.5, 0.0, 0.0,
                    -0.5, -0.5, -0.5, 0.0, 1.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0,
                    0.5, 0.5, -0.5, 1.0, 1.0,
                    0.5, 0.5, 0.5, 1.0, 0.0,
                    0.5, 0.5, 0.5, 1.0, 0.0,
                    -0.5, 0.5, 0.5, 0.0, 0.0,
                    -0.5, 0.5, -0.5, 0.0, 1.0
                ];
                _this.cubePositions = [
                    vec3.fromValues(0.0, 0.0, 0.0),
                    vec3.fromValues(2.0, 5.0, -15.0),
                    vec3.fromValues(-1.5, -2.2, -2.5),
                    vec3.fromValues(-3.8, -2.0, -12.3),
                    vec3.fromValues(2.4, -0.4, -3.5),
                    vec3.fromValues(-1.7, 3.0, -7.5),
                    vec3.fromValues(1.3, -2.0, -2.5),
                    vec3.fromValues(1.5, 2.0, -2.5),
                    vec3.fromValues(1.5, 0.2, -1.5),
                    vec3.fromValues(-1.3, 1.0, -1.5)
                ];
                _this.width = 960;
                _this.height = 540;
                _this.key_status = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                _this.started = false;
                _this.angle = 0;
                _this.cameraPos = vec3.fromValues(0, 0, 3);
                _this.cameraFront = vec3.fromValues(0.0, 0.0, -1.0);
                _this.cameraUp = vec3.fromValues(0.0, 1.0, 0.0);
                _this.cameraSpeed = 0.2;
                return _this;
            }
            Camera2.prototype.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, program, vert, frag, vertexShader, fragmentShader, info, info, info, VBO, v, aPos, aTexCoord, ourTexture, tex, img;
                    var _this = this;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                gl = this.work.gl;
                                program = this.program = gl.createProgram();
                                return [4 /*yield*/, $.get('./glsl/transfromations2.vert')];
                            case 1:
                                vert = _a.sent();
                                return [4 /*yield*/, $.get('./glsl/transfromations2.frag')];
                            case 2:
                                frag = _a.sent();
                                vertexShader = gl.createShader(gl.VERTEX_SHADER);
                                fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                                gl.shaderSource(vertexShader, vert);
                                gl.shaderSource(fragmentShader, frag);
                                // console.log(vertexShader,fragmentShader);
                                gl.compileShader(vertexShader);
                                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                                    info = gl.getShaderInfoLog(vertexShader);
                                    throw info;
                                }
                                gl.compileShader(fragmentShader);
                                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                                    info = gl.getShaderInfoLog(fragmentShader);
                                    throw info;
                                }
                                gl.attachShader(program, vertexShader);
                                gl.attachShader(program, fragmentShader);
                                gl.linkProgram(program);
                                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                                    info = gl.getProgramInfoLog(program);
                                    throw 'Could not compile WebGL program. \n\n' + info;
                                }
                                VBO = this.VBO = gl.createBuffer();
                                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                                v = new Float32Array(this.vertices);
                                gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                                aPos = gl.getAttribLocation(program, 'aPos');
                                gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 0);
                                gl.enableVertexAttribArray(aPos);
                                aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
                                gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                                gl.enableVertexAttribArray(aTexCoord);
                                ourTexture = gl.getUniformLocation(program, 'ourTexture');
                                tex = this.tex = gl.createTexture();
                                return [4 /*yield*/, ImageUtils.load("/assets/cg001.jpg")];
                            case 3:
                                img = _a.sent();
                                gl.useProgram(program);
                                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                                gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                                gl.activeTexture(gl.TEXTURE0);
                                gl.bindTexture(gl.TEXTURE_2D, tex);
                                //一系列tex处理阐述
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                                //texture bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering.
                                //因为材质图默认很多图片不是所谓的标准尺寸，2^n这种 需要拉伸
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
                                gl.uniform1i(ourTexture, 0);
                                gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                                WorkManager.getInstance().keydown("w", function () {
                                    _this.key_status.w = true;
                                });
                                WorkManager.getInstance().keydown("a", function () {
                                    _this.key_status.a = true;
                                });
                                WorkManager.getInstance().keydown("s", function () {
                                    _this.key_status.s = true;
                                });
                                WorkManager.getInstance().keydown("d", function () {
                                    _this.key_status.d = true;
                                });
                                WorkManager.getInstance().keyup("w", function () {
                                    _this.key_status.w = false;
                                });
                                WorkManager.getInstance().keyup("a", function () {
                                    _this.key_status.a = false;
                                });
                                WorkManager.getInstance().keyup("s", function () {
                                    _this.key_status.s = false;
                                });
                                WorkManager.getInstance().keyup("d", function () {
                                    _this.key_status.d = false;
                                });
                                return [2 /*return*/];
                        }
                    });
                });
            };
            Camera2.prototype.update = function () {
                var gl = this.work.gl;
                gl.useProgram(this.program);
                gl.enable(gl.DEPTH_TEST);
                // gl.enable(gl.CULL_FACE);
                gl.clearColor(0.2, 0.3, 0.3, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.tex);
                this.angle++;
                // let transform = gl.getUniformLocation(this.program, 'transform');
                var model = gl.getUniformLocation(this.program, 'model');
                var view = gl.getUniformLocation(this.program, 'view');
                var projection = gl.getUniformLocation(this.program, 'projection');
                var promat = mat4.create();
                var viewmat = mat4.create();
                mat4.perspective(promat, 3.14 / 4, this.width / this.height, 0.1, 100.0);
                gl.uniformMatrix4fv(projection, false, promat);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
                // let radius = 10.0;
                // let camX = Math.sin(this.angle / 100) * radius;
                // let camZ = Math.cos(this.angle / 100) * radius;
                if (this.key_status.w) {
                    this.cameraPos[2] += this.cameraFront[2] * this.cameraSpeed;
                }
                if (this.key_status.s) {
                    this.cameraPos[2] -= this.cameraFront[2] * this.cameraSpeed;
                }
                if (this.key_status.a) {
                    var v = vec3.create();
                    vec3.cross(v, this.cameraFront, this.cameraUp);
                    this.cameraPos[0] -= v[0] * this.cameraSpeed;
                    this.cameraPos[1] -= v[1] * this.cameraSpeed;
                    this.cameraPos[2] -= v[2] * this.cameraSpeed;
                }
                if (this.key_status.d) {
                    var v = vec3.create();
                    vec3.cross(v, this.cameraFront, this.cameraUp);
                    this.cameraPos[0] += v[0] * this.cameraSpeed;
                    this.cameraPos[1] += v[1] * this.cameraSpeed;
                    this.cameraPos[2] += v[2] * this.cameraSpeed;
                }
                mat4.lookAt(viewmat, this.cameraPos, vec3.add(vec3.create(), this.cameraPos, this.cameraFront), this.cameraUp);
                gl.uniformMatrix4fv(view, false, viewmat);
                for (var i in this.cubePositions) {
                    var modelvec3 = this.cubePositions[i];
                    var modelmat = mat4.create();
                    mat4.translate(modelmat, modelmat, modelvec3);
                    mat4.rotate(modelmat, modelmat, this.angle * (~~i + 2) / 10 * Math.PI / 180, vec3.fromValues(0.05, 0.0, 0.05));
                    gl.uniformMatrix4fv(model, false, modelmat);
                    gl.drawArrays(gl.TRIANGLES, 0, 36);
                }
            };
            return Camera2;
        }(HomeWork));
        intro.Camera2 = Camera2;
    })(intro = Work.intro || (Work.intro = {}));
})(Work || (Work = {}));
var WorkWithTextures = /** @class */ (function (_super) {
    __extends(WorkWithTextures, _super);
    function WorkWithTextures() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vertices = [
            0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.5, 1.0,
            0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
            -0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 // 左下
        ];
        //            // 左上
        // public readonly vertices = [
        //     -0.5, -0.5, 0.0,
        //     0.5, -0.5, 0.0,
        //     0.0, 0.5, 0.0
        // ]
        _this.texCoords = [
            0.0, 0.0,
            1.0, 0.0,
            0.5, 1.0
        ];
        return _this;
    }
    WorkWithTextures.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gl, program, vert, frag, vertexShader, fragmentShader, info, info, info, VBO, v, aPos, aColor, aTexCoord, ourTexture, tex, img;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.work.gl;
                        program = gl.createProgram();
                        return [4 /*yield*/, $.get('./glsl/Tex.vert')];
                    case 1:
                        vert = _a.sent();
                        return [4 /*yield*/, $.get('./glsl/Tex.frag')];
                    case 2:
                        frag = _a.sent();
                        vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(vertexShader, vert);
                        gl.shaderSource(fragmentShader, frag);
                        // console.log(vertexShader,fragmentShader);
                        gl.compileShader(vertexShader);
                        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(vertexShader);
                            throw info;
                        }
                        gl.compileShader(fragmentShader);
                        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(fragmentShader);
                            throw info;
                        }
                        gl.attachShader(program, vertexShader);
                        gl.attachShader(program, fragmentShader);
                        gl.linkProgram(program);
                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                            info = gl.getProgramInfoLog(program);
                            throw 'Could not compile WebGL program. \n\n' + info;
                        }
                        VBO = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        v = new Float32Array(this.vertices);
                        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                        aPos = gl.getAttribLocation(program, 'aPos');
                        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 0);
                        gl.enableVertexAttribArray(aPos);
                        aColor = gl.getAttribLocation(program, 'aColor');
                        gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aColor);
                        aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
                        gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 6 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aTexCoord);
                        ourTexture = gl.getUniformLocation(program, 'ourTexture');
                        tex = gl.createTexture();
                        return [4 /*yield*/, ImageUtils.load("/assets/1.png")];
                    case 3:
                        img = _a.sent();
                        gl.useProgram(program);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        //一系列tex处理阐述
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        //texture bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering.
                        //因为材质图默认很多图片不是所谓的标准尺寸，2^n这种 需要拉伸
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
                        gl.uniform1i(ourTexture, 0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        // gl.clear(gl.COLOR_BUFFER_BIT);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.vertices.length / 8);
                        return [2 /*return*/];
                }
            });
        });
    };
    return WorkWithTextures;
}(HomeWork));
var WorkWithTextures2 = /** @class */ (function (_super) {
    __extends(WorkWithTextures2, _super);
    function WorkWithTextures2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vertices = [
            0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
            -0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
            -0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0
        ];
        _this.texCoords = [
            0.0, 0.0,
            1.0, 0.0,
            0.5, 1.0
        ];
        _this.indices = [
            0, 1, 2,
            0, 3, 2
        ];
        return _this;
    }
    WorkWithTextures2.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gl, program, vert, frag, vertexShader, fragmentShader, info, info, info, VBO, v, EBO, aPos, aColor, aTexCoord, ourTexture, tex, img;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.work.gl;
                        program = gl.createProgram();
                        return [4 /*yield*/, $.get('./glsl/Tex.vert')];
                    case 1:
                        vert = _a.sent();
                        return [4 /*yield*/, $.get('./glsl/Tex.frag')];
                    case 2:
                        frag = _a.sent();
                        vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(vertexShader, vert);
                        gl.shaderSource(fragmentShader, frag);
                        // console.log(vertexShader,fragmentShader);
                        gl.compileShader(vertexShader);
                        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(vertexShader);
                            throw info;
                        }
                        gl.compileShader(fragmentShader);
                        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(fragmentShader);
                            throw info;
                        }
                        gl.attachShader(program, vertexShader);
                        gl.attachShader(program, fragmentShader);
                        gl.linkProgram(program);
                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                            info = gl.getProgramInfoLog(program);
                            throw 'Could not compile WebGL program. \n\n' + info;
                        }
                        VBO = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        v = new Float32Array(this.vertices);
                        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                        EBO = gl.createBuffer();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(this.indices), gl.STATIC_DRAW);
                        aPos = gl.getAttribLocation(program, 'aPos');
                        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 0);
                        gl.enableVertexAttribArray(aPos);
                        aColor = gl.getAttribLocation(program, 'aColor');
                        gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aColor);
                        aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
                        gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 6 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aTexCoord);
                        ourTexture = gl.getUniformLocation(program, 'ourTexture');
                        tex = gl.createTexture();
                        return [4 /*yield*/, ImageUtils.load("/assets/1.png")];
                    case 3:
                        img = _a.sent();
                        gl.useProgram(program);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        //一系列tex处理阐述
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        //texture bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering.
                        //因为材质图默认很多图片不是所谓的标准尺寸，2^n这种 需要拉伸
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
                        gl.uniform1i(ourTexture, 0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
                        // gl.clear(gl.COLOR_BUFFER_BIT);
                        // gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.vertices.length / 8);
                        gl.drawElements(gl.TRIANGLE_STRIP, 6, gl.UNSIGNED_BYTE, 0);
                        return [2 /*return*/];
                }
            });
        });
    };
    WorkWithTextures2.prototype.update = function () {
    };
    return WorkWithTextures2;
}(HomeWork));
var WorkWithTransformations = /** @class */ (function (_super) {
    __extends(WorkWithTransformations, _super);
    function WorkWithTransformations() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vertices = [
            0.5, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
            -0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
            -0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0 // 左上
        ];
        _this.texCoords = [
            0.0, 0.0,
            1.0, 0.0,
            0.5, 1.0
        ];
        _this.indices = [
            0, 1, 2,
            0, 3, 2
        ];
        _this.started = false;
        _this.angle = 0;
        return _this;
    }
    WorkWithTransformations.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gl, program, vert, frag, vertexShader, fragmentShader, info, info, info, VBO, v, EBO, aPos, aColor, aTexCoord, ourTexture, tex, img;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.work.gl;
                        program = this.program = gl.createProgram();
                        return [4 /*yield*/, $.get('./glsl/transfromations.vert')];
                    case 1:
                        vert = _a.sent();
                        return [4 /*yield*/, $.get('./glsl/Tex.frag')];
                    case 2:
                        frag = _a.sent();
                        vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(vertexShader, vert);
                        gl.shaderSource(fragmentShader, frag);
                        // console.log(vertexShader,fragmentShader);
                        gl.compileShader(vertexShader);
                        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(vertexShader);
                            throw info;
                        }
                        gl.compileShader(fragmentShader);
                        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(fragmentShader);
                            throw info;
                        }
                        gl.attachShader(program, vertexShader);
                        gl.attachShader(program, fragmentShader);
                        gl.linkProgram(program);
                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                            info = gl.getProgramInfoLog(program);
                            throw 'Could not compile WebGL program. \n\n' + info;
                        }
                        VBO = this.VBO = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        v = new Float32Array(this.vertices);
                        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                        EBO = this.EBO = gl.createBuffer();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(this.indices), gl.STATIC_DRAW);
                        aPos = gl.getAttribLocation(program, 'aPos');
                        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 0);
                        gl.enableVertexAttribArray(aPos);
                        aColor = gl.getAttribLocation(program, 'aColor');
                        gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aColor);
                        aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
                        gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 8 * v.BYTES_PER_ELEMENT, 6 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aTexCoord);
                        ourTexture = gl.getUniformLocation(program, 'ourTexture');
                        tex = this.tex = gl.createTexture();
                        return [4 /*yield*/, ImageUtils.load("/assets/1.png")];
                    case 3:
                        img = _a.sent();
                        gl.useProgram(program);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        //一系列tex处理阐述
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        //texture bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering.
                        //因为材质图默认很多图片不是所谓的标准尺寸，2^n这种 需要拉伸
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
                        gl.uniform1i(ourTexture, 0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
                        // gl.clear(gl.COLOR_BUFFER_BIT);
                        // gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.vertices.length / 8);
                        gl.drawElements(gl.TRIANGLE_STRIP, 6, gl.UNSIGNED_BYTE, 0);
                        return [2 /*return*/];
                }
            });
        });
    };
    WorkWithTransformations.prototype.update = function () {
        var gl = this.work.gl;
        gl.useProgram(this.program);
        gl.clearColor(0.2, 0.3, 0.3, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
        this.angle++;
        var transform = gl.getUniformLocation(this.program, 'transform');
        var mat = mat4.create();
        var m2 = mat4.create();
        // let m3 = mat4.create();
        // mat4.identity(mat);
        mat4.rotateZ(m2, mat, this.angle * Math.PI / 180);
        // mat4.rotateX(m3, m2, this.angle * Math.PI / 180);
        // let m4 = mat4.perspective(m3, glMatrix.toRadian(45.0 / 180.0), 1, 0.1, 100);
        // console.log(m2);
        gl.uniformMatrix4fv(transform, false, m2);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.EBO);
        gl.drawElements(gl.TRIANGLE_STRIP, 6, gl.UNSIGNED_BYTE, 0);
    };
    return WorkWithTransformations;
}(HomeWork));
var WorkWithTransformations2 = /** @class */ (function (_super) {
    __extends(WorkWithTransformations2, _super);
    function WorkWithTransformations2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vertices = [
            -0.5, -0.5, -0.5, 0.0, 0.0,
            0.5, -0.5, -0.5, 1.0, 0.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            -0.5, 0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 0.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 1.0,
            0.5, 0.5, 0.5, 1.0, 1.0,
            -0.5, 0.5, 0.5, 0.0, 1.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, 0.5, -0.5, 1.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, 0.5, 0.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, -0.5, 1.0, 1.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, 0.5, -0.5, 0.0, 1.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, 0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, -0.5, 0.0, 1.0
        ];
        _this.texCoords = [
            0.0, 0.0,
            1.0, 0.0,
            0.5, 1.0
        ];
        // public readonly indices = [
        //     0, 1, 2,
        //     0, 3, 2
        // ];
        _this.width = 600;
        _this.height = 600;
        _this.started = false;
        _this.angle = 0;
        return _this;
    }
    WorkWithTransformations2.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gl, program, vert, frag, vertexShader, fragmentShader, info, info, info, VBO, v, aPos, aTexCoord, ourTexture, tex, img;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.work.gl;
                        program = this.program = gl.createProgram();
                        return [4 /*yield*/, $.get('./glsl/transfromations2.vert')];
                    case 1:
                        vert = _a.sent();
                        return [4 /*yield*/, $.get('./glsl/transfromations2.frag')];
                    case 2:
                        frag = _a.sent();
                        vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(vertexShader, vert);
                        gl.shaderSource(fragmentShader, frag);
                        // console.log(vertexShader,fragmentShader);
                        gl.compileShader(vertexShader);
                        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(vertexShader);
                            throw info;
                        }
                        gl.compileShader(fragmentShader);
                        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(fragmentShader);
                            throw info;
                        }
                        gl.attachShader(program, vertexShader);
                        gl.attachShader(program, fragmentShader);
                        gl.linkProgram(program);
                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                            info = gl.getProgramInfoLog(program);
                            throw 'Could not compile WebGL program. \n\n' + info;
                        }
                        VBO = this.VBO = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        v = new Float32Array(this.vertices);
                        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                        aPos = gl.getAttribLocation(program, 'aPos');
                        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 0);
                        gl.enableVertexAttribArray(aPos);
                        aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
                        gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aTexCoord);
                        ourTexture = gl.getUniformLocation(program, 'ourTexture');
                        tex = this.tex = gl.createTexture();
                        return [4 /*yield*/, ImageUtils.load("/assets/cg001.jpg")];
                    case 3:
                        img = _a.sent();
                        gl.useProgram(program);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        //一系列tex处理阐述
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        //texture bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering.
                        //因为材质图默认很多图片不是所谓的标准尺寸，2^n这种 需要拉伸
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
                        gl.uniform1i(ourTexture, 0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        return [2 /*return*/];
                }
            });
        });
    };
    // public EBO;
    WorkWithTransformations2.prototype.update = function () {
        var gl = this.work.gl;
        gl.useProgram(this.program);
        gl.enable(gl.DEPTH_TEST);
        // gl.enable(gl.CULL_FACE);
        gl.clearColor(0.2, 0.3, 0.3, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
        this.angle++;
        // let transform = gl.getUniformLocation(this.program, 'transform');
        var model = gl.getUniformLocation(this.program, 'model');
        var view = gl.getUniformLocation(this.program, 'view');
        var projection = gl.getUniformLocation(this.program, 'projection');
        var modelmat = mat4.create();
        // let m2 = mat4.create();
        // let mat = mat4.create();
        var promat = mat4.create();
        var viewmat = mat4.create();
        // let v1 = vec3.fromValues(0.5, 1.0, 1.0)
        // mat4.rotate(m2, mat, this.angle * Math.PI / 180, v1);
        // mat4.translate(m2,mat4.create(), vec3.fromValues(0, 0, ));
        // mat4.lookAt(viewmat, [4, 4, 8], [0, 0, 0], [0, 1, 0]);
        mat4.rotate(modelmat, mat4.create(), this.angle * Math.PI / 180, vec3.fromValues(1.0, 0.0, 1.0));
        mat4.perspective(promat, 3.14 / 4, 1.0, 0.1, 100.0);
        mat4.translate(viewmat, mat4.create(), vec3.fromValues(0, 0, -3.0));
        // gl.enable(gl.DEPTH_TEST);
        // gl.uniformMatrix4fv(transform, false, m2);
        gl.uniformMatrix4fv(model, false, modelmat);
        gl.uniformMatrix4fv(view, false, viewmat);
        gl.uniformMatrix4fv(projection, false, promat);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
        // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.EBO);
        // gl.drawElements(gl.TRIANGLE_STRIP, 6, gl.UNSIGNED_BYTE, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 36);
    };
    return WorkWithTransformations2;
}(HomeWork));
var WorkWithTransformations3 = /** @class */ (function (_super) {
    __extends(WorkWithTransformations3, _super);
    function WorkWithTransformations3() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vertices = [
            -0.5, -0.5, -0.5, 0.0, 0.0,
            0.5, -0.5, -0.5, 1.0, 0.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            -0.5, 0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 0.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 1.0,
            0.5, 0.5, 0.5, 1.0, 1.0,
            -0.5, 0.5, 0.5, 0.0, 1.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, 0.5, -0.5, 1.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, 0.5, 0.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            0.5, -0.5, -0.5, 1.0, 1.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            0.5, -0.5, 0.5, 1.0, 0.0,
            -0.5, -0.5, 0.5, 0.0, 0.0,
            -0.5, -0.5, -0.5, 0.0, 1.0,
            -0.5, 0.5, -0.5, 0.0, 1.0,
            0.5, 0.5, -0.5, 1.0, 1.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            0.5, 0.5, 0.5, 1.0, 0.0,
            -0.5, 0.5, 0.5, 0.0, 0.0,
            -0.5, 0.5, -0.5, 0.0, 1.0
        ];
        _this.texCoords = [
            0.0, 0.0,
            1.0, 0.0,
            0.5, 1.0
        ];
        _this.cubePositions = [
            vec3.fromValues(0.0, 0.0, 0.0),
            vec3.fromValues(2.0, 5.0, -15.0),
            vec3.fromValues(-1.5, -2.2, -2.5),
            vec3.fromValues(-3.8, -2.0, -12.3),
            vec3.fromValues(2.4, -0.4, -3.5),
            vec3.fromValues(-1.7, 3.0, -7.5),
            vec3.fromValues(1.3, -2.0, -2.5),
            vec3.fromValues(1.5, 2.0, -2.5),
            vec3.fromValues(1.5, 0.2, -1.5),
            vec3.fromValues(-1.3, 1.0, -1.5)
        ];
        // public readonly indices = [
        //     0, 1, 2,
        //     0, 3, 2
        // ];
        _this.width = 600;
        _this.height = 600;
        _this.started = false;
        _this.angle = 0;
        return _this;
    }
    WorkWithTransformations3.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gl, program, vert, frag, vertexShader, fragmentShader, info, info, info, VBO, v, aPos, aTexCoord, ourTexture, tex, img;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.work.gl;
                        program = this.program = gl.createProgram();
                        return [4 /*yield*/, $.get('./glsl/transfromations2.vert')];
                    case 1:
                        vert = _a.sent();
                        return [4 /*yield*/, $.get('./glsl/transfromations2.frag')];
                    case 2:
                        frag = _a.sent();
                        vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(vertexShader, vert);
                        gl.shaderSource(fragmentShader, frag);
                        // console.log(vertexShader,fragmentShader);
                        gl.compileShader(vertexShader);
                        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(vertexShader);
                            throw info;
                        }
                        gl.compileShader(fragmentShader);
                        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(fragmentShader);
                            throw info;
                        }
                        gl.attachShader(program, vertexShader);
                        gl.attachShader(program, fragmentShader);
                        gl.linkProgram(program);
                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                            info = gl.getProgramInfoLog(program);
                            throw 'Could not compile WebGL program. \n\n' + info;
                        }
                        VBO = this.VBO = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        v = new Float32Array(this.vertices);
                        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                        aPos = gl.getAttribLocation(program, 'aPos');
                        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 0);
                        gl.enableVertexAttribArray(aPos);
                        aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
                        gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 5 * v.BYTES_PER_ELEMENT, 3 * v.BYTES_PER_ELEMENT);
                        gl.enableVertexAttribArray(aTexCoord);
                        ourTexture = gl.getUniformLocation(program, 'ourTexture');
                        tex = this.tex = gl.createTexture();
                        return [4 /*yield*/, ImageUtils.load("/assets/cg001.jpg")];
                    case 3:
                        img = _a.sent();
                        gl.useProgram(program);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, tex);
                        //一系列tex处理阐述
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        //texture bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering.
                        //因为材质图默认很多图片不是所谓的标准尺寸，2^n这种 需要拉伸
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
                        gl.uniform1i(ourTexture, 0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        return [2 /*return*/];
                }
            });
        });
    };
    // public EBO;
    WorkWithTransformations3.prototype.update = function () {
        var gl = this.work.gl;
        gl.useProgram(this.program);
        gl.enable(gl.DEPTH_TEST);
        // gl.enable(gl.CULL_FACE);
        gl.clearColor(0.2, 0.3, 0.3, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
        this.angle++;
        // let transform = gl.getUniformLocation(this.program, 'transform');
        var model = gl.getUniformLocation(this.program, 'model');
        var view = gl.getUniformLocation(this.program, 'view');
        var projection = gl.getUniformLocation(this.program, 'projection');
        // let m2 = mat4.create();
        // let mat = mat4.create();
        var promat = mat4.create();
        var viewmat = mat4.create();
        // let v1 = vec3.fromValues(0.5, 1.0, 1.0)
        // mat4.rotate(m2, mat, this.angle * Math.PI / 180, v1);
        // mat4.translate(m2,mat4.create(), vec3.fromValues(0, 0, ));
        // mat4.lookAt(viewmat, [4, 4, 8], [0, 0, 0], [0, 1, 0]);
        mat4.perspective(promat, 3.14 / 4, 1.0, 0.1, 100.0);
        mat4.translate(viewmat, mat4.create(), vec3.fromValues(0, 0, -3.0));
        // gl.enable(gl.DEPTH_TEST);
        // gl.uniformMatrix4fv(transform, false, m2);
        gl.uniformMatrix4fv(view, false, viewmat);
        gl.uniformMatrix4fv(projection, false, promat);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
        // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.EBO);
        // gl.drawElements(gl.TRIANGLE_STRIP, 6, gl.UNSIGNED_BYTE, 0);
        for (var i in this.cubePositions) {
            var modelvec3 = this.cubePositions[i];
            var modelmat = mat4.create();
            mat4.translate(modelmat, modelmat, modelvec3);
            mat4.rotate(modelmat, modelmat, this.angle * (~~i + 2) / 10 * Math.PI / 180, vec3.fromValues(0.05, 0.0, 0.05));
            gl.uniformMatrix4fv(model, false, modelmat);
            gl.drawArrays(gl.TRIANGLES, 0, 36);
        }
    };
    return WorkWithTransformations3;
}(HomeWork));
var WrokWithTriangle = /** @class */ (function (_super) {
    __extends(WrokWithTriangle, _super);
    function WrokWithTriangle() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vertices = [
            -0.5, -0.5, 0.0,
            0.5, -0.5, 0.0,
            0.0, 0.5, 0.0
        ];
        return _this;
    }
    WrokWithTriangle.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gl, program, vert, frag, vertexShader, fragmentShader, info, info, info, VBO, v, aPos;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.work.gl;
                        program = gl.createProgram();
                        return [4 /*yield*/, $.get('./glsl/def.vert')];
                    case 1:
                        vert = _a.sent();
                        return [4 /*yield*/, $.get('./glsl/def.frag')];
                    case 2:
                        frag = _a.sent();
                        vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(vertexShader, vert);
                        gl.shaderSource(fragmentShader, frag);
                        // console.log(vertexShader,fragmentShader);
                        gl.compileShader(vertexShader);
                        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(vertexShader);
                            throw info;
                        }
                        gl.compileShader(fragmentShader);
                        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                            info = gl.getShaderInfoLog(fragmentShader);
                            throw info;
                        }
                        gl.attachShader(program, vertexShader);
                        gl.attachShader(program, fragmentShader);
                        gl.linkProgram(program);
                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                            info = gl.getProgramInfoLog(program);
                            throw 'Could not compile WebGL program. \n\n' + info;
                        }
                        VBO = gl.createBuffer();
                        //glBindBuffer(GL_ARRAY_BUFFER, VBO);  
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        v = new Float32Array(this.vertices);
                        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
                        aPos = gl.getAttribLocation(program, 'aPos');
                        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 3 * v.BYTES_PER_ELEMENT, 0);
                        gl.enableVertexAttribArray(aPos);
                        // gl.enableVertexAttribArray(0);
                        // gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 3*4, 0);
                        // gl.bindAttribLocation(program,1,"v3Position");
                        gl.useProgram(program);
                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
                        gl.drawArrays(gl.TRIANGLES, 0, 3);
                        return [2 /*return*/];
                }
            });
        });
    };
    WrokWithTriangle.prototype.update = function () {
    };
    WrokWithTriangle.prototype.destroy = function () {
    };
    return WrokWithTriangle;
}(HomeWork));
